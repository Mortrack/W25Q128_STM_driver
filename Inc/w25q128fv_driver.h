/**@file
 * @brief	W25Q128FV Flash Memory's driver Header file.
 *
 * @defgroup w25q128fv W25Q128FV Flash Memory module
 * @{
 *
 * @brief   This module provides the functions, definitions, structures and variables that together work as the driver
 *          for the W25Q128FV Flash Memory Device with the purpose of being used by the application firmware.
 *
 * @details As for now, this @ref w25q128fv provides the necessary things so that it is possible to read, write and
 *          erase data in Standard SPI. However, it is still pending to add functions to be able to use the full
 *          features available in the W25Q128FV Flash Memory Device such as the "32KB Block Erase" Instruction or the
 *          Instructions available for the Dual or Quad SPI Modes for example.
 * @details The way that the @ref w25q128fv works is that this module must first be initialized via the
 *          @ref init_w25q128fv_module function in order to enable all the other functions to work properly. In
 *          addition, this initialization function is the means with which the implementer will designate to the
 *          @ref w25q128fv the SPI of the MCU/MPU that this module will use (remember to enable the given SPI at the
 *          STM32CubeMX app) to read, write and erase data from/to the W25Q128FV Flash Memory Device. Also, this
 *          initialization function is where the implementer will also tell what Output GPIO Pin is connected to the CS
 *          Pin of the W25Q128FV Device.
 * 
 * @note    It is also important to highlight is that this @ref w25q128fv has included the "stm32f1xx_hal.h" header file
 *          to be able to use the SPI in this module. However, this header file is specifically meant for the STM32F1
 *          series devices. If yours is from a different type, then you will have to substitute the right one here for
 *          your particular STMicroelectronics device. However, if you cant figure out what the name of that header file
 *          is, then simply substitute that line of code from this @ref w25q128fv by: #include "main.h"
 *
 * @details <b><u>Code used for validating the @ref w25q128fv , but that can also be used as a reference as an
 *          example code for using this Driver Library:</u></b>
 *
 * @code
  #include <stdio.h>	// Library from which "printf" is located at.
  #include <stdint.h> // This library contains the aliases: uint8_t, uint16_t, uint32_t, etc.
  #include "w25q128fv_driver.h" // This custom Mortrack's library contains the functions, definitions and variables that together operate as the driver for the W25Q128FV Flash Memory Device.

  SPI_HandleTypeDef hspi1;
  UART_HandleTypeDef huart1;

  void SystemClock_Config(void); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
  static void MX_GPIO_Init(void); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
  static void MX_SPI1_Init(void); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
  static void MX_USART1_UART_Init(void); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).

  int main(void)
  {
      HAL_Init(); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
      SystemClock_Config(); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
      MX_GPIO_Init(); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
      MX_SPI1_Init(); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).
      MX_USART1_UART_Init(); // STM32CubeMx autogenerated code, whose function contents will not be cited here for simplicity (see the STM32CubeMx PDF report for more details on the configurations made).

      // ########################################################## //
      // ##### INITIALIZE THE W25Q128FV DRIVER LIBRARY MODULE ##### //
      // ########################################################## //
      W25Q128FV_Status ret; // Variable that will be used to hold the Exception codes after calling a function from the W25Q128FV Driver Library.
      W25Q128FV_peripherals_def_t flash_memory_peripherals; // Variable to hold the W25Q128FV Flash Memory Device's Peripherals Definition parameters structure.
      flash_memory_peripherals.CS.GPIO_Port = GPIOB; // I specify here that my W25Q128FV Device's CS Pin is connected in a Pin B of my MCU.
      flash_memory_peripherals.CS.GPIO_Pin = GPIO_PIN_6; // I specify here that my W25Q128FV Device's CS Pin is connected to a Pin number 6 of my MCU.
      printf("INFO: Initializing the W25Q128FV Driver Library Module...\r\n");
      init_w25q128fv_module(&hspi1, &flash_memory_peripherals); // Initialize the W25Q128FV Driver Library Module.
      printf("SUCCESS: The W25Q128FV Driver Library Module has been successfully initialized.\r\n");

      // ######################################################## //
      // ##### INITIALIZE THE W25Q128FV FLASH MEMORY DEVICE ##### //
      // ######################################################## //
      printf("INFO: Sending a Software Reset request to the W25Q128FV Flash Memory Device...\r\n");
      ret = w25q128fv_software_reset();
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_software_reset() function exception code value = %d.\r\n", ret);
      }
      else
      {
          printf("SUCCESS: Software Reset request has been successfully sent to the W25Q128FV Flash Memory Device.\r\n");
      }

      // ############################################################### //
      // ##### READING THE ID OF THE W25Q128FV FLASH MEMORY DEVICE ##### //
      // ############################################################### //
      uint32_t w25q128fv_id = 0; // Variable that will be used to store the ID of the W25Q128FV Flash Memory Device.
      printf("INFO: Getting the 24-bit ID of the W25Q128FV Flash Memory Device...\r\n");
      ret = w25q128fv_read_id(&w25q128fv_id);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_read_id() function exception code value = %d.\r\n", ret);
      }
      else
      {
          printf("SUCCESS: A 24-bit ID with a value of %lu_d of the W25Q128FV Flash Memory Device has been obtained.\r\n", w25q128fv_id);
      }

      // ########################################################################################## //
      // ##### ERASING THE W25Q128FV FLASH MEMORY DEVICE BEFORE VALIDATING THE DRIVER LIBRARY ##### //
      // ########################################################################################## //
      printf("INFO: Erasing all the data contained in the W25Q128FV Flash Memory Device before starting to test the Driver Library in it...\r\n");
      ret = w25q128fv_chip_erase();
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_chip_erase() function exception code value = %d.\r\n", ret);
      }
      else
      {
          printf("SUCCESS: All the data inside the W25Q128FV Flash Memory Device has been erased.\r\n");
      }

      // ############################################################### //
      // ##### WRITING DATA INTO THE W25Q128FV FLASH MEMORY DEVICE ##### //
      // ############################################################### //
      // ----- WRITING TEST 1: Writing 16 bytes at the beginning of the W25Q128FV Flash Memory (i.e., Page 0) ----- //
      uint8_t page0_data[256]; // Variable where the generated data that wants to be stored at the W25Q128FV Flash Memory Page 0 will be stored in our MCU/MPU.
      memset(page0_data, 'X', 256); // Setting all bytes of "page0_data" to the value of the 'X' ASCII Character.
      page0_data[0] = 'H';
      page0_data[1] = 'e';
      page0_data[2] = 'l';
      page0_data[3] = 'l';
      page0_data[4] = 'o';
      page0_data[5] = ' ';
      page0_data[6] = 'f';
      page0_data[7] = 'r';
      page0_data[8] = 'o';
      page0_data[9] = 'm';
      page0_data[10] = ' ';
      page0_data[11] = 'P';
      page0_data[12] = 'a';
      page0_data[13] = 'g';
      page0_data[14] = 'e';
      page0_data[15] = '0';
      printf("WRITING TEST 1: Writing 16 bytes at the beginning of the W25Q128FV Flash Memory (i.e., Page 0)...\r\n");
      ret = w25q128fv_write_flash_memory(0, 0, 16, page0_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_write_flash_memory() at WRITING TEST 1 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program to stop here.
      }
      else
      {
          printf("SUCCESS: w25q128fv_write_flash_memory() at WRITING TEST 1 has successfully sent the required Page Program Instructions.\r\n");
      }

      // ----- WRITING TEST 2: Writing data into two full pages of the W25Q128FV Flash Memory with only one function call (into Page 10 and 11) ----- //
      uint8_t page10_and_11_data[512]; // Variable where the generated data that wants to be stored at the W25Q128FV Flash Memory Pages 10 and 11 will be stored in our MCU/MPU.
      uint8_t number_to_store = 0; // Temporal variable that will be used to hold the value that wants to be assigned to the current byte of the "page10_and_11_data" variable.
      for (uint16_t i=0; i<512; i++)
      {
          page10_and_11_data[i] = number_to_store++; // Store the desired data into the "page10_and_11_data" variable.
      }
      printf("WRITING TEST 2: Writing data into two full pages of the W25Q128FV Flash Memory with only one function call (into Page 10 and 11)...\r\n");
      ret = w25q128fv_write_flash_memory(10, 0, 512, page10_and_11_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_write_flash_memory() at WRITING TEST 2 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      else
      {
          printf("SUCCESS: w25q128fv_write_flash_memory() at WRITING TEST 2 has successfully sent the required Page Program Instructions.\r\n");
      }

      // ----- WRITING TEST 3: Writing 17 bytes of data into Page 15 of the W25Q128FV Flash Memory with an offset of 246 bytes such that the expected result is to end up writing the first 10 bytes of data into the last 10 bytes of page 15 and the next 7 bytes of data into the beginning of page 16 (due to page overflow because of the specified bytes offset) ----- //
      uint8_t page15_data[256]; // Variable where the generated data that wants to be stored at the W25Q128FV Flash Memory Page 15 will be stored in our MCU/MPU.
      memset(page15_data, 'X', 256); // Setting all bytes of "page15_data" to the value of the 'X' ASCII Character.
      page15_data[0] = 'H';
      page15_data[1] = 'e';
      page15_data[2] = 'l';
      page15_data[3] = 'l';
      page15_data[4] = 'o';
      page15_data[5] = ' ';
      page15_data[6] = 'f';
      page15_data[7] = 'r';
      page15_data[8] = 'o';
      page15_data[9] = 'm';
      page15_data[10] = ' ';
      page15_data[11] = 'P';
      page15_data[12] = 'a';
      page15_data[13] = 'g';
      page15_data[14] = 'e';
      page15_data[15] = '1';
      page15_data[16] = '5';
      printf("WRITING TEST 3: Writing 17 bytes of data into Page 15 of the W25Q128FV Flash Memory with an offset of 246 bytes such that the expected result is to end up writing the first 10 bytes of data into the last 10 bytes of page 15 and the next 7 bytes of data into the beginning of page 16 (due to page overflow because of the specified bytes offset)...\r\n");
      ret = w25q128fv_write_flash_memory(15, 246, 17, page15_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_write_flash_memory() at WRITING TEST 3 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      else
      {
          printf("SUCCESS: w25q128fv_write_flash_memory() at WRITING TEST 3 has successfully sent the required Page Program Instructions.\r\n");
      }

      // ----- WRITING TEST 4: Writing 256 bytes into the last Page of the W25Q128FV Flash Memory (i.e., Page 65355) ----- //
      uint8_t page65355_data[256]; // Variable where the generated data that wants to be stored at the W25Q128FV Flash Memory Page 65355 will be stored in our MCU/MPU.
      memset(page65355_data, 'X', 256); // Setting all bytes of "page65355_data" to the value of the 'X' ASCII Character.
      page65355_data[0] = 'H';
      page65355_data[1] = 'e';
      page65355_data[2] = 'l';
      page65355_data[3] = 'l';
      page65355_data[4] = 'o';
      page65355_data[5] = ' ';
      page65355_data[6] = 'f';
      page65355_data[7] = 'r';
      page65355_data[8] = 'o';
      page65355_data[9] = 'm';
      page65355_data[10] = ' ';
      page65355_data[11] = 'P';
      page65355_data[12] = 'a';
      page65355_data[13] = 'g';
      page65355_data[14] = 'e';
      page65355_data[15] = '6';
      page65355_data[16] = '5';
      page65355_data[17] = '3';
      page65355_data[18] = '5';
      page65355_data[19] = '5';
      printf("WRITING TEST 4: Writing 256 bytes into the last Page of the W25Q128FV Flash Memory (i.e., Page 65355)...\r\n");
      ret = w25q128fv_write_flash_memory(65355, 0, 256, page65355_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_write_flash_memory() at WRITING TEST 4 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      else
      {
          printf("SUCCESS: w25q128fv_write_flash_memory() at WRITING TEST 4 has successfully sent the required Page Program Instructions.\r\n");
      }

      // ----- WRITING TEST 5: Validating that the W25Q128FV Driver Library returns the expected Exception Code whenever asking it to Write one byte of Data into a Flash Memory Address beyond the existing ones.  ----- //
      printf("WRITING TEST 5: Validating that the W25Q128FV Driver Library returns the expected Exception Code whenever asking it to Write one byte of Data into a Flash Memory Address beyond the existing ones...\r\n");
      ret = w25q128fv_write_flash_memory(65355, 237, 20, page65355_data);
      if (ret == W25Q128FV_EC_ERR)
      {
          printf("SUCESS: w25q128fv_write_flash_memory() at WRITING TEST 5 has returned the expected exception code value = %d.\r\n", ret);
      }
      else
      {
          printf("ERROR: w25q128fv_write_flash_memory() at WRITING TEST 5 has returned an unexpected exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }

      // ############################################################### //
      // ##### READING DATA FROM THE W25Q128FV FLASH MEMORY DEVICE ##### //
      // ############################################################### //
      uint8_t is_reading_writing_test_validation_successful = 1; // Variable used to set a 1 if a certain Reading Writing Test is successful or to set a 0 if otherwise.
      // ----- READING WRITING TEST 1: Expecting to see the 16 bytes that were supposedly written at the beginning of the W25Q128FV Flash Memory (i.e., Page 0) ----- //
      uint8_t page0_read_data[256]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Page 0 into our MCU/MPU.
      memset(page0_read_data, 0, 256); // Setting all bytes of "page0_data" to the value of 0 in decimal as initial values before reading data from the W25Q128FV Device.
      printf("READING WRITING TEST 1: Expecting to see the 16 bytes that were supposedly written at the beginning of the W25Q128FV Flash Memory (i.e., Page 0)...\r\n");
      ret = w25q128fv_read_flash_memory(0, 0, 256, page0_read_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_write_flash_memory() at READING WRITING TEST 1 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      for (uint8_t i=0; i<16; i++)
      {
          if (page0_read_data[i] != page0_data[i]) // Expecting that the read data from the W25Q128FV Flash Memory matches the one that was sent.
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      for (uint16_t i=16; i<256; i++)
      {
          if (page0_read_data[i] != 0xFF) // Expecting these other read bytes from the W25Q128FV Flash Memory to have the reset value since they were not used (i.e., 0xFF).
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Reading Writing Test 1 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Reading Writing Test 1 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }

      // ----- READING WRITING TEST 2: Expecting to see the two pages of the W25Q128FV Flash Memory that were supposedly fully written with data with only one function call (into Page 10 and 11) ----- //
      uint8_t page10_and_11_read_data[512]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Page 10 and 11 into our MCU/MPU.
      memset(page10_and_11_read_data, 0, 512); // Setting all bytes of "page10_and_11_read_data" to the value of 0 in decimal.
      printf("READING WRITING TEST 2: Expecting to see the two pages of the W25Q128FV Flash Memory that were supposedly fully written with data with only one function call (into Page 10 and 11)...\r\n");
      ret = w25q128fv_fast_read_flash_memory(10, 0, 512, page10_and_11_read_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_fast_read_flash_memory() at READING WRITING TEST 2 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      is_reading_writing_test_validation_successful = 1; // Resetting the value of this Flag Variable.
      for (uint16_t i=0; i<512; i++)
      {
          if (page10_and_11_read_data[i] != page10_and_11_data[i]) // Expecting that the read data from the W25Q128FV Flash Memory matches the one that was sent.
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Reading Writing Test 2 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Reading Writing Test 2 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }

      // ----- READING WRITING TEST 3: Expecting to see the 17 bytes that were supposedly written at Page 15 of the W25Q128FV Flash Memory with an offset of 246 bytes ----- //
      uint8_t page15_read_data[256]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Page 15 into our MCU/MPU.
      memset(page15_read_data, 0, 256); // Setting all bytes of "page15_read_data" to the value of 0 in decimal.
      printf("READING WRITING TEST 3: Expecting to see the 17 bytes that were supposedly written at Page 15 of the W25Q128FV Flash Memory with an offset of 246 bytes...\r\n");
      ret = w25q128fv_read_flash_memory(15, 246, 18, page15_read_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_write_flash_memory() at READING WRITING TEST 3 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      is_reading_writing_test_validation_successful = 1; // Reseting the value of this Flag Variable.
      for (uint8_t i=0; i<17; i++)
      {
          if (page15_read_data[i] != page15_data[i]) // Expecting that the read data from the W25Q128FV Flash Memory matches the one that was sent.
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (page15_read_data[17] != 0xFF) // Expecting this other read byte from the W25Q128FV Flash Memory to have the reset value since it was not used (i.e., 0xFF).
      {
          is_reading_writing_test_validation_successful = 0;
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Reading Writing Test 3 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Reading Writing Test 3 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }

      // ----- READING WRITING TEST 4: Expecting to see the 256 bytes that were supposedly written into the last Page of the W25Q128FV Flash Memory (i.e., Page 65355) ----- //
      uint8_t page65355_read_data[256]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Page 65355 into our MCU/MPU.
      memset(page65355_read_data, 0, 256); // Setting all bytes of "page65355_read_data" to the value of 0 in decimal.
      printf("READING WRITING TEST 4 and 5: Expecting to see the 256 bytes that were supposedly written into the last Page of the W25Q128FV Flash Memory (i.e., Page 65355) only...\r\n");
      ret = w25q128fv_fast_read_flash_memory(65355, 0, 256, page65355_read_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_fast_read_flash_memory() at READING WRITING TEST 4 and 5 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      is_reading_writing_test_validation_successful = 1; // Reseting the value of this Flag Variable.
      for (uint16_t i=0; i<256; i++)
      {
          if (page65355_read_data[i] != page65355_data[i]) // Expecting that the read data from the W25Q128FV Flash Memory matches the one that was sent.
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Reading Writing Test 4 and 5 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Reading Writing Test 4 and 5 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }


      // ############################################################### //
      // ##### ERASING DATA FROM THE W25Q128FV FLASH MEMORY DEVICE ##### //
      // ############################################################### //
      // ----- ERASING TEST 1: Erasing the contents of the first W25Q128FV Flash Memory Sector (i.e., erasing from Page 0 up to Page 15) ----- //
      printf("ERASING TEST 1: Erasing the contents of the first W25Q128FV Flash Memory Sector (i.e., erasing from Page 0 up to Page 15)...\r\n");
      ret = w25q128fv_erase_sector(0);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_erase_sector() at ERASING TEST 1 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      uint8_t sector0_data[15*256]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Sector 0 into our MCU/MPU.
      memset(sector0_data, 0, 15*256); // Setting all bytes of "sector0_data" to the value of 0 in decimal.
      ret = w25q128fv_fast_read_flash_memory(0, 0, 15*256, sector0_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_fast_read_flash_memory() at ERASING TEST 1 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      is_reading_writing_test_validation_successful = 1; // Resetting the value of this Flag Variable.
      for (uint16_t i=0; i<(15*256); i++)
      {
          if (sector0_data[i] != 0xFF) // Expecting these read bytes from the W25Q128FV Flash Memory to have the reset value since they were not used (i.e., 0xFF).
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      uint8_t page16_read_data[8]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Page 16 into our MCU/MPU.
      memset(page16_read_data, 0, 8); // Setting all bytes of "page16_read_data" to the value of 0 in decimal.
      ret = w25q128fv_fast_read_flash_memory(16, 0, 8, page16_read_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_fast_read_flash_memory() at ERASING TEST 1 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      for (uint8_t i=0; i<7; i++)
      {
          if (page16_read_data[i] != page15_data[i+10]) // Expecting that the read data from the W25Q128FV Flash Memory matches the ones that were sent.
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (page16_read_data[8] != 0xFF) // Expecting this read byte from the W25Q128FV Flash Memory to have the reset value since it was not used (i.e., 0xFF).
      {
          is_reading_writing_test_validation_successful = 0;
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Erasing Test 1 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Erasing Test 1 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }

      // ----- ERASING TEST 2: Erasing the contents of the second W25Q128FV Flash Memory Sector (i.e., erasing from Page 16 up to Page 31) ----- //
      printf("ERASING TEST 2: Erasing the contents of the second W25Q128FV Flash Memory Sector (i.e., erasing from Page 16 up to Page 31)...\r\n");
      ret = w25q128fv_erase_sector(1);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_erase_sector() at ERASING TEST 2 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      uint8_t sector1_data[15*256]; // Variable where this program will store the data read from the W25Q128FV Flash Memory Sector 1 into our MCU/MPU.
      memset(sector1_data, 0, 15*256); // Setting all bytes of "sector1_data" to the value of 0 in decimal.
      ret = w25q128fv_read_flash_memory(16, 0, 15*256, sector1_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_fast_read_flash_memory() at ERASING TEST 2 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      is_reading_writing_test_validation_successful = 1; // Resetting the value of this Flag Variable.
      for (uint16_t i=0; i<(15*256); i++)
      {
          if (sector1_data[i] != 0xFF) // Expecting these read bytes from the W25Q128FV Flash Memory to have the reset value since they were not used (i.e., 0xFF).
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Erasing Test 2 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Erasing Test 2 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }

      // ----- ERASING TEST 3: Making sure that erasing sectors beyond the existing ones returns the proper Error Exception Code. ----- //
      printf("ERASING TEST 3: Making sure that erasing sectors beyond the existing ones returns the proper Error Exception Code...\r\n");
      ret = w25q128fv_erase_sector(4085);
      if (ret == W25Q128FV_EC_ERR)
      {
          printf("SUCCESS: Erasing Test 3 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The w25q128fv_erase_sector() function at Erasing Test 3 returned an unexpected Exception code = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }

      // ----- ERASING TEST 4: Erasing ALL the contents of the W25Q128FV Flash Memory (i.e., Execute a Chip Erase Instruction) ----- //
      printf("ERASING TEST 4: Erasing ALL the contents of the W25Q128FV Flash Memory (i.e., Execute a Chip Erase Instruction)...\r\n");
      ret = w25q128fv_chip_erase();
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: W25Q128FV_EC_OK() at ERASING TEST 4 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      memset(page65355_data, 0, 256); // Resetting all bytes of "page65355_data" to the value of 0 in decimal.
      ret = w25q128fv_read_flash_memory(65355, 0, 256, page65355_data);
      if (ret != W25Q128FV_EC_OK)
      {
          printf("ERROR: w25q128fv_fast_read_flash_memory() at ERASING TEST 4 has returned an exception code value = %d.\r\n", ret);
          while(1); // If there is an Error, then make the program stop here.
      }
      // CHECK THAT THE DATA THAT WAS READ FROM THE W25Q128FV DEVICE IS THE EXPECTED ONE //
      is_reading_writing_test_validation_successful = 1; // Resetting the value of this Flag Variable.
      for (uint16_t i=0; i<256; i++)
      {
          if (page65355_data[i] != 0xFF) // Expecting these read bytes from the W25Q128FV Flash Memory to have the reset value since they were not used (i.e., 0xFF).
          {
              is_reading_writing_test_validation_successful = 0;
          }
      }
      if (is_reading_writing_test_validation_successful == 1)
      {
          printf("SUCCESS: Erasing Test 4 was successful.\r\n");
      }
      else
      {
          printf("ERROR: The data that was read from the W25Q128FV Flash Memory at Erasing Test 4 is not what was expected to be.\r\n");
          while(1); // If there is an Error, then make the program stop here.
      }

      printf("\r\n##### ALL TESTS HAVE BEEN CONCLUDED #####\r\n");

      while (1); // Stop the program here.
  }

  // USER CODE BEGIN 4

  // Compiler definition to be able to use the @ref printf function from stdio.h library in the STM32 MCU being used in order to print characters via the UART1 Peripheral but by using that @ref printf function.
  #ifdef __GNUC__
  // With GCC, small printf (option LD Linker->Libraries->Small printf set to 'Yes') calls __io_putchar().
      int __io_putchar(int ch)
  #else
  int fputc(int ch, FILE *f)
  #endif // __GNUC__
  {
      // NOTE: The characters written into the UART1 Protocol will be looped until the end of transmission.
      HAL_UART_Transmit(&huart1, (uint8_t *) &ch, 1, HAL_MAX_DELAY);
      return ch;
  }

  // USER CODE END 4
 * @endcode
 *
 * @author 	Cesar Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 23, 2024.
 *
 * @note    Credits are given to <a href=https://www.youtube.com/@ControllersTech>ControllersTech</a> for their
 *          contributions on their version of the W25Q Flash Memory Devices Driver Library, from which the author of
 *          the @ref w25q128fv started to learn about the W25Q Series Devices.
 */

#ifndef W25Q128FV_DRIVER_H
#define W25Q128FV_DRIVER_H

#include "stm32f1xx_hal.h" // This is the HAL Driver Library for the STM32F1 series devices. If yours is from a different type, then you will have to substitute the right one here for your particular STMicroelectronics device. However, if you cant figure out what the name of that header file is, then simply substitute this line of code by: #include "main.h"
#include <stdint.h> // This library contains the aliases: uint8_t, uint16_t, uint32_t, etc.

#define W25Q128FV_SPI_TIMEOUT   (8500)    /**< @brief Designated timeout in milliseconds for our MCU/MPU to send/receive SPI transactions/data. @note Make sure to adapt this value so that your MCU/MPU is able to complete a full read, write or any other type of request to your W25Q128FV Flash Memory Device. The best value for this definition will vary depending on the Clock Frequency that you set in your MCU/MPU. */

/**@brief	W25Q128FV Exception codes.
 *
 * @details	These Exception Codes are returned by the functions of the @ref w25q128fv to indicate the resulting status
 *          of having executed the process contained in each of those functions. For example, to indicate that the
 *          process executed by a certain function was successful or that it has failed.
 */
typedef enum
{
    W25Q128FV_EC_OK     = 0U,    //!< W25Q128FV Driver Process was successful. @note The code from the @ref HAL_ret_handler function contemplates that this value will match the one given for \c HAL_OK from @ref HAL_StatusTypeDef .
    W25Q128FV_EC_STOP   = 1U,    //!< W25Q128FV Driver Process has been stopped.
    W25Q128FV_EC_NR	    = 2U,	 //!< W25Q128FV Driver Process has concluded with no response from W25Q128FV Device.
    W25Q128FV_EC_NA     = 3U,    //!< W25Q128FV Driver Data received or to be received Not Applicable.
    W25Q128FV_EC_ERR    = 4U     //!< W25Q128FV Driver Process has failed.
} W25Q128FV_Status;

/**@brief	W25Q128FV Driver GPIO Definition parameters structure.
 *
 * @details This contains all the fields required to associate a certain GPIO pin to the Chip Select pin (i.e., The CS
 *          pin) of the W25Q128FV Device Hardware.
 */
typedef struct __attribute__ ((__packed__)) {
    GPIO_TypeDef *GPIO_Port;	//!< Type Definition of the GPIO peripheral port to which this @ref W25Q128FV_GPIO_def_t structure will be associated with.
    uint16_t GPIO_Pin;			//!< Pin number of the GPIO peripheral from to this @ref W25Q128FV_GPIO_def_t structure will be associated with.
} W25Q128FV_GPIO_def_t;

/**@brief	W25Q128FV Flash Memory Device's Peripherals Definition parameters structure.
 *
 * @details This contains all the fields required to associate the corresponding peripheral pins of our MCU towards
 *          which the terminals of the W25Q128FV Flash Memory Device are connected to.
 */
typedef struct __attribute__ ((__packed__)) {
    W25Q128FV_GPIO_def_t CS;	//!< Type Definition of the GPIO peripheral port to which the A terminal of the 5641AS 7-segment Display device is connected to.
} W25Q128FV_peripherals_def_t;

/**@brief   Sends a Software Reset request to the W25Q128FV Flash Memory Device.
 *
 * @details For this purpose, both the Enable Reset and the Reset Device Instructions described in the datasheet are
 *          sent to the W25Q128FV Device in that orderly fashion.
 * @details If these Instructions are successfully sent to the W25Q128FV Device, then a 1ms delay will be made at the
 *          end of the processes made inside this function in order to give time to the W25Q128FV Device to conclude its
 *          Software Reset process.
 * @note    The W25Q128FV Datasheet states that the W25Q128FV Device will take an approximate of 30us to apply a
 *          Software Reset. However, this @ref w25q128fv_software_reset function will call instead a 1ms Delay due to
 *          that this is the lowest possible delay that can be achieved with the @ref HAL_Delay function and also for
 *          simplicity reasons (i.e., To not employ a Timer for this purpose or to create a function with NOP Assembler
 *          Commands or anything else more elaborated than simply calling the @ref HAL_Delay function).
 *
 * @retval	W25Q128FV_EC_OK     if the Software Reset request was successfully sent to the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    if anything else went wrong.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 01, 2024.
 */
W25Q128FV_Status w25q128fv_software_reset(void);

/**@brief   Reads the JEDEC ID of the W25Q128FV Flash Memory Device and then formulates a 24-bit ID with it.
 *
 * @details This function will send the Read JEDEC ID Instruction to the W25Q128FV Device, after which it is expected to
 *          receive the Manufacture ID, Memory Type and Capacity values from that device according to the W25Q128FV
 *          datasheet.
 * @details If a response is received from the W25Q128FV Device after sending the Read JEDEC ID Instruction to it, then
 *          this function will formulate a 24-bit ID with that response, where the byte value corresponding to the
 *          Capacity will be assigned first, then the Memory Type value will be assigned in the next byte, and then the
 *          Manufacturer ID value will be placed in the third byte (i.e., Each of the bytes are basically shifted).
 * @note    The author of this code did not invented this 24-bit ID methodology, concept and/or idea and was instead
 *          taken from
 *          <a href=https://controllerstech.com/w25q-flash-series-part-1-read-id>CONTROLLERSTECH Shop & Learn website</a>,
 *          whose explanation is also available at their
 *          <a href=https://www.youtube.com/watch?v=OSfu4ST3dlY>YouTube video</a>.
 *
 * @param[out] w25q128fv_id Pointer to the Memory Location Address where it is desired to store the 24-bit ID that this
 *                          function formulates.
 *
 * @retval	W25Q128FV_EC_OK     if the W25Q128FV 24-bit ID is successfully formulated and stored into the Memory Address
 *                              pointed to by the \p w25q128fv_id param.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    if anything else went wrong.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 01, 2024.
 */
W25Q128FV_Status w25q128fv_read_id(uint32_t *w25q128fv_id);

/**@brief   Reads a desired segment of the Flash Memory of the W25Q128FV device.
 *
 * @details This function will send the Read Data Instruction to the W25Q128FV Device, which also includes the start of
 *          the Flash Memory Address where it is desired to start reading data. After that, according to the W25Q128FV
 *          datasheet, it is expected to receive the actual Data contained from that Start Flash Memory Address up to
 *          the request Flash Memory Address. Note that the received Data can be from one or more Flash Memory Pages
 *          from a single Read Data Instruction.
 *
 * @param start_page        Flash Memory Page of the W25Q128FV Device from which it is desired to start reading data,
 *                          where this value may be any from 0 up to 65355.
 * @param page_bytes_offset Offset in bytes inside the requested Flash Memory Page of the W25Q128FV Device from which it
 *                          is desired to start reading data.
 * @param size              Size in bytes to read from the W25Q128FV Device.
 * @param[out] dst          Pointer to the start of the Memory Location Address of our MCU/MPU where it is desired to
 *                          store Flash Memory data read from the W25Q128FV Device.
 *
 * @note    Note that the valid values for both the \p page_bytes_offset and \p size params can be any from 0 up to
 *          @ref W25Q128FV_FLASH_MEMORY_TOTAL_SIZE_IN_BYTES , as long as the W25Q128FV Flash Memory Addresses to read
 *          data are existing ones.
 *
 * @retval	W25Q128FV_EC_OK     if the W25Q128FV Read Data Instruction was successfully sent to the W25Q128FV Device and
 *                              if the data that was read from the Device was successfully stored into the Memory
 *                              Address pointed to by the \p dst param.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    if the W25Q128FV Flash Memory location addresses to be read exceed the existing ones or
 *                              if anything else went wrong.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 10, 2024.
 */
W25Q128FV_Status w25q128fv_read_flash_memory(uint32_t start_page, uint8_t page_bytes_offset, uint32_t size, uint8_t *dst);

/**@brief   Reads a desired segment of the Flash Memory of the W25Q128FV Device in Fast Mode.
 *
 * @note    This Fast Mode must be used whenever the W25Q128FV Device is operating at its highest possible frequency
 *          (i.e., at 104MHz Clock Frequency).
 *
 * @details This function will send the Fast Read Instruction to the W25Q128FV Device, which also includes the start of
 *          the Flash Memory Address where it is desired to start reading data and eight don't care bits for the eight
 *          Dummy Clocks of the Fast Read Instruction. After that, according to the W25Q128FV datasheet, it is expected
 *          to receive the actual Data contained from that Start Flash Memory Address up to the request Flash Memory
 *          Address. Note that the received Data can be from one or more Flash Memory Pages from a single Read Data
 *          Instruction.
 *
 * @param start_page        Flash Memory Page of the W25Q128FV Device from which it is desired to start reading data,
 *                          where this value may be any from 0 up to 65355.
 * @param page_bytes_offset Offset in bytes inside the requested Flash Memory Page of the W25Q128FV Device from which it
 *                          is desired to start reading data.
 * @param size              Size in bytes to read from the W25Q128FV Device.
 * @param[out] dst          Pointer to the start of the Memory Location Address of our MCU/MPU where it is desired to
 *                          store Flash Memory data read from the W25Q128FV Device.
 *
 * @note    Note that the valid values for both the \p page_bytes_offset and \p size params can be any from 0 up to
 *          @ref W25Q128FV_FLASH_MEMORY_TOTAL_SIZE_IN_BYTES , as long as the W25Q128FV Flash Memory Addresses to read
 *          data are existing ones.
 *
 * @retval	W25Q128FV_EC_OK     if the W25Q128FV Fast Read Instruction was successfully sent to the W25Q128FV Device and
 *                              if the data that was read from the Device was successfully stored into the Memory
 *                              Address pointed to by the \p dst param.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    if the W25Q128FV Flash Memory location addresses to be read exceed the existing ones or
 *                              if anything else went wrong.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 10, 2024.
 */
W25Q128FV_Status w25q128fv_fast_read_flash_memory(uint32_t start_page, uint8_t page_bytes_offset, uint32_t size, uint8_t *dst);

/**@brief   Erases the data contained in a desired Flash Memory Sector of the W25Q128FV Flash Memory Device.
 *
 * @note    A Sector Erase stands for the minimum amount of erasable bytes in a W25Q128FV Device.
 * @note    The size of a Sector is 16 pages (i.e., 4096 bytes) in a W25Q128FV Device.
 *
 * @details This function will send the Write Enable Instruction to the W25Q128FV Device in order to enable it to erase
 *          data in it. Subsequently, the Sector Erase Instruction will be sent to the W25Q128FV Device, which will
 *          include the start of the Flash Memory Address of the Sector whose data wants to be erased. Then, as stated
 *          in the W25Q128FV datasheet, a 400ms Delay will be made in order to give sufficient time to the W25Q128FV
 *          Device to finish erasing the desired Sector. Finally, this function will conclude by sending the Write
 *          Disable Instruction to the W25Q128FV Device.
 *
 * @param sector_number     Flash Memory Sector of the W25Q128FV Device whose data wants to be erased. Note that this
 *                          value may be any from 0 up to @ref W25Q128FV_TOTAL_SECTORS .
 *
 * @retval	W25Q128FV_EC_OK     if the Write enable, Sector Erase and Write Disable instructions were successfully sent
 *                              to the W25Q128FV Device.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    <ul>
 *                                  <li>
 *                                      If, the value of the Sector Number, given via the \p sector_number param,
 *                                      corresponds to a non-existent Sector in the W25Q128FV Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If the Write Enable Instruction could not be successfully send to the W25Q128FV
 *                                      Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If the Write Disable Instruction could not be successfully send to the W25Q128FV
 *                                      Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If anything else went wrong.
 *                                  </li>
 *                              </ul>
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 10, 2024.
 */
W25Q128FV_Status w25q128fv_erase_sector(uint32_t sector_number);
// TODO: Pending to write a function for the "32KB Block Erase" and "64KB Block Erase"Instructions of a W25Q128FV Device, which should both have a very similar (almost identical) code with respect to the @ref w25q128fv_erase_sector function.

/**@brief   Erases all the data contained in the W25Q128FV Flash Memory Device.
 *
 * @details This function will send the Write Enable Instruction to the W25Q128FV Device in order to enable it to erase
 *          data in it. Subsequently, the Chip Erase Instruction will be sent to the W25Q128FV Device. Then, as stated
 *          in the W25Q128FV datasheet, a 200 seconds Delay will be made in order to give sufficient time to the
 *          W25Q128FV Device to finish erasing all its data. Finally, this function will conclude by sending the
 *          Write Disable Instruction to the W25Q128FV Device.
 *
 * @retval	W25Q128FV_EC_OK     if the Write enable, Chip Erase and Write Disable instructions were successfully sent
 *                              to the W25Q128FV Device.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    <ul>
 *                                  <li>
 *                                      If the Write Enable Instruction could not be successfully send to the W25Q128FV
 *                                      Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If the Write Disable Instruction could not be successfully send to the W25Q128FV
 *                                      Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If anything else went wrong.
 *                                  </li>
 *                              </ul>
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 10, 2024.
 */
W25Q128FV_Status w25q128fv_chip_erase(void);

/**@brief   Writes some desired data into the Flash Memory of the W25Q128FV device.
 *
 * @details This function will send the desired data in several segmented parts, where for each part, the Write Enable
 *          Instruction to the W25Q128FV Device in order to enable it to write data in it. Subsequently, a Page Program
 *          Instruction will be sent to the W25Q128FV Device with up to 255 bytes of the desired data so that they are
 *          written into that Device. Then, as stated in the W25Q128FV datasheet, a 3 milliseconds Delay will be made in
 *          order to give sufficient time to the W25Q128FV Device to finish programming the requested data. After that,
 *          this function will send a Write Disable Instruction to the W25Q128FV Device. Finally, this entire process
 *          that has been described will be repeated as many times as required in order to write the entire desired data
 *          into the W25Q128FV Device.
 * @details Each time a Page Program Instruction is sent to the W25Q128FV Device, this function will send only one byte
 *          of the desired data to that Device only whenever the currently W25Q128FV Flash Memory Page has not been
 *          written after this function has been called (prior calls are not taken into account) and, at the same time,
 *          whenever this function is to start writing data from the first W25Q128FV Flash Memory Address that belongs
 *          to that W25Q128FV Flash Memory Page. On the other hand, any other case, the bytes of the desired data
 *          will be send at each Page Program Instruction until the currently W25Q128FV Flash Memory Page being written
 *          is full of data, which should be from 1 up to 255 bytes per Page Program Instruction. The number of bytes
 *          sent to the W25Q128FV Device will depend on whether you defined a value on the \p page_bytes_offset param
 *          during the first W25Q128FV Flash Memory Page being written, if the remaining bytes to be written can fit
 *          into the current W25Q128FV Flash Memory Page or if 255 bytes of data can fit into the current W25Q128FV
 *          Flash Memory Page.
 *
 * @note    The reason for limiting sending and writing data up to 255 bytes at a time, whenever using the Page Program
 *          Instruction, is because of how the Page Program Instruction actually works according to the W25Q128FV
 *          datasheet. In more details, the reason is because only a whole W25Q128FV Flash Memory Page minus 1 byte can
 *          be consecutively written at a time, since if a whole Page is written in a single instruction, then the last
 *          byte must strictly be set to 0x00, and if more bytes than the size of a Page is written in a single
 *          instruction, then whenever exceeding that size, the W25Q128FV Device will start overwriting the bytes from
 *          the beginning of that same Page. As a result, due to these explained reasons, it was decided that this
 *          function will send and write from 1 up to 255 bytes at a time, until all the requested data is written into
 *          the W25Q128FV Device.
 * @note    <b style="color:red">WARNING:</b> It is responsibility of the implementer of this @ref w25q128fv to Write
 *          data into the W25Q128FV Flash Memory once only and to erase the written data before writing new ones in
 *          those corresponding W25Q128FV Flash Memory Addresses. This is because this is how Flash Memories in general
 *          are supposed to work and it is how the @ref w25q128fv contemplates that the W25Q128FV Device works.
 *
 * @param start_page        Flash Memory Page of the W25Q128FV Device from which it is desired to start writing data,
 *                          where this value may be any from 0 up to 65355.
 * @param page_bytes_offset Offset in bytes inside the requested Flash Memory Page of the W25Q128FV Device from which it
 *                          is desired to start writing data.
 * @param size              Size in bytes to write into the W25Q128FV Device.
 * @param[out] src          Pointer to the start of the Memory Location Address of our MCU/MPU where the desired data to
 *                          be stored into the W25Q128FV Flash Memory is located at.
 *
 * @note    Note that the valid values for both the \p page_bytes_offset and \p size params can be any from 0 up to
 *          @ref W25Q128FV_FLASH_MEMORY_TOTAL_SIZE_IN_BYTES , as long as the W25Q128FV Flash Memory Addresses to write
 *          data are existing ones.
 *
 * @retval	W25Q128FV_EC_OK     if the W25Q128FV Page Program Instruction was successfully sent to the W25Q128FV Device
 *                              and if the requested data, from where the \p src param points to, was successfully
 *                              written into the W25Q128FV Flash Memory.
 * @retval  W25Q128FV_EC_NR     if there was no response from the W25Q128FV Flash Memory Device.
 * @retval  W25Q128FV_EC_ERR    <ul>
 *                                  <li>
 *                                      If the W25Q128FV Flash Memory location addresses to be written exceed the
 *                                      existing ones.
 *                                  </li>
 *                                  <li>
 *                                      If the Write Enable Instruction could not be successfully send to the W25Q128FV
 *                                      Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If the Write Disable Instruction could not be successfully send to the W25Q128FV
 *                                      Flash Memory Device.
 *                                  </li>
 *                                  <li>
 *                                      If anything else went wrong.
 *                                  </li>
 *                              </ul>
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 22, 2024.
 */
W25Q128FV_Status w25q128fv_write_flash_memory(uint32_t start_page, uint8_t page_bytes_offset, uint32_t size, uint8_t *src);

/**@brief   Initializes the @ref w25q128fv in order to be able to use its provided functions.
 *
 * @details This function stores in the @ref p_hspi Global Static Pointer the address of the SPI Handle Structure of
 *          the SPI that is desired to be used by the @ref w25q128fv to write, read and erase data to/from/in a
 *          W25Q128FV Flash Memory Device. In addition, it also stores in the @ref p_w25q128fv_peripherals Global Static
 *          Pointer the address that points to the W25Q128FV Flash Memory Device's Peripherals Definition parameters
 *          structure so that the @ref w25q128fv can allow our MCU/MPU to communicate, via its Pin Peripherals, with the
 *          W25Q128FV Device.
 *
 * @param[in] hspi          Pointer to the SPI Handle Structure of the SPI that it is desired to use in the
 *                          @ref w25q128fv to write, read and erase data to/from/in a W25Q128FV Flash Memory Device.
 * @param[in] peripherals   Pointer to the W25Q128FV Flash Memory Device's Peripherals Definition parameters structure
 *                          that should contain the required data of the Pin Peripherals at which the W25Q128FV Flash
 *                          Memory Device is expected to be connected at.
 *
 * @author	César Miranda Meza (cmirandameza3@hotmail.com)
 * @date	April 16, 2024.
 */
void init_w25q128fv_module(SPI_HandleTypeDef *hspi, W25Q128FV_peripherals_def_t *peripherals);

#endif /* W25Q128FV_DRIVER_H */

/** @} */
